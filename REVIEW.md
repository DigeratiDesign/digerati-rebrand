# Code Review Notes

## 1. Defer lifecycle tasks instead of executing them during registration (`src/index.ts`)
- `PHASES.domReady.tasks` and `PHASES.webflowReady.tasks` mix plain function references with immediate calls such as `Core.widowControl({...})`. Because `Task` is declared as `() => void`, the eagerly invoked items return `undefined` and are filtered out by the runtime type guard, so those side effects only run at import time and never during their intended phase. Wrap each invocation in a zero-argument closure (e.g. `() => Core.widowControl({...})`) or redesign the registry to accept `{ run: Task }` records so configuration objects can still be captured lazily.【F:src/index.ts†L21-L85】
- `eventBus.emit(event, undefined)` is only present to satisfy the `emit` signature even when the payload type is `void`. Once the event bus allows payloads to be optional for `void` events (see item 2), the emit call can omit the `undefined` argument and simplify each phase runner.【F:src/index.ts†L69-L83】

## 2. Tighten the EventBus generics and overloads (`src/digerati/utils/eventBus.ts`, `src/digerati/events/types.ts`)
- `listeners` is currently stored as `Map<keyof Events, Set<Listener<any>>>`, forcing casts on every registration and removal. Model the storage as `Map<K, Set<Listener<Events[K]>>>` (with a helper `type ListenerMap<E> = { [K in keyof E]?: Set<Listener<E[K]>> }`) so the compiler enforces listener signatures without `as any` at call sites.【F:src/digerati/utils/eventBus.ts†L5-L44】
- Add an overload `emit<K extends keyof Events>(event: K): void` that is selected when `Events[K]` is `void`, or make the payload parameter optional with a conditional type. This removes the need for dummy `{}` or `undefined` arguments in modules that expose `void` events.【F:src/digerati/utils/eventBus.ts†L25-L37】【F:src/digerati/events/types.ts†L8-L29】
- Several events that are conceptually signal-only (`autoHideNavbar:hide/show/destroyed`, `pageBlurTitle:destroyed`) are typed as `{}`. Retyping them as `void` lets callers drop the empty object allocations entirely once the overload is in place.【F:src/digerati/events/types.ts†L8-L57】

## 3. Honour the configurable delays in the auto-hide controller (`src/digerati/modules/autoHideNavbarOnScroll.ts`)
- The constructor destructures `initialDelayWithoutHash` and `hashActivationFallbackMs`, but the values are discarded after destructuring; the activation timers still rely on hard-coded `100` and `500` millisecond constants in `init`. Persist those options on the instance (e.g. `this.initialDelayWithoutHash = initialDelayWithoutHash`) and reference the stored values inside the `setTimeout` calls so consumers can tune the behaviour.【F:src/digerati/modules/autoHideNavbarOnScroll.ts†L42-L223】
- The factory wraps the controller options in an `as any` cast because `AutoHideNavbarOnScrollController` only accepts a subset of the exported options. Align the constructor signature with `AutoHideNavbarOnScrollOptions` (or pass `opts` straight through) to keep the API type-safe without the escape hatch.【F:src/digerati/modules/autoHideNavbarOnScroll.ts†L250-L285】

## 4. Keep `autoGroup` consistent with the logger's debug gating (`src/digerati/utils/logger.ts`)
- All of the logger helpers gate their console calls on `shouldLog()`, except `autoGroup`, which always opens a collapsed group. In production this still emits console noise even though everything else is suppressed. Wrap the `console.groupCollapsed` / `console.groupEnd` calls in the same `DEBUG` guard (and fall back gracefully when the methods are unavailable) so `autoGroup` respects the environment just like `log`, `warn`, and friends.【F:src/digerati/utils/logger.ts†L11-L121】
